<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MP3 Tools</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lamejs/1.2.1/lame.min.js"></script>
  <!-- Google APIs for Drive Picker -->
  <script src="https://apis.google.com/js/api.js" async defer></script>
  <script src="https://accounts.google.com/gsi/client" async defer></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #1a1a2e;
      color: #e0e0e0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .container {
      background: #16213e;
      border-radius: 12px;
      padding: 40px;
      max-width: 750px;
      width: 100%;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      position: relative;
    }

    /* ── Logo ── */
    .logo {
      position: absolute;
      top: 16px;
      right: 16px;
      max-width: 80px;
      max-height: 80px;
      border-radius: 8px;
      object-fit: contain;
    }

    /* ── Tabs ── */
    .tabs {
      display: flex;
      gap: 4px;
      margin-bottom: 28px;
      border-bottom: 2px solid #0f3460;
      padding-bottom: 0;
      padding-right: 90px;
    }

    .tab-btn {
      flex: 1;
      padding: 10px 10px;
      border: none;
      border-bottom: 3px solid transparent;
      border-radius: 8px 8px 0 0;
      background: transparent;
      color: #888;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      transition: color 0.2s, border-color 0.2s, background 0.2s;
      width: auto;
    }

    .tab-btn:hover {
      color: #ccc;
      background: rgba(233, 69, 96, 0.05);
    }

    .tab-btn.active {
      color: #e94560;
      border-bottom-color: #e94560;
      background: rgba(233, 69, 96, 0.08);
    }

    .tab-panel {
      display: none;
    }

    .tab-panel.active {
      display: block;
    }

    /* ── Shared styles ── */
    h2 {
      font-size: 1.4rem;
      margin-bottom: 6px;
      color: #e94560;
    }

    .subtitle {
      font-size: 0.9rem;
      color: #888;
      margin-bottom: 24px;
    }

    .upload-area {
      border: 2px dashed #333;
      border-radius: 8px;
      padding: 32px;
      text-align: center;
      cursor: pointer;
      transition: border-color 0.2s, background 0.2s;
      margin-bottom: 10px;
    }

    .upload-area:hover, .upload-area.dragover {
      border-color: #e94560;
      background: rgba(233, 69, 96, 0.05);
    }

    .upload-area.has-file {
      border-color: #4ecca3;
      background: rgba(78, 204, 163, 0.05);
    }

    .upload-area input[type="file"] {
      display: none;
    }

    .upload-label {
      font-size: 0.95rem;
      color: #aaa;
    }

    .file-name {
      margin-top: 8px;
      font-size: 0.85rem;
      color: #4ecca3;
      word-break: break-all;
    }

    .upload-alt {
      text-align: center;
      margin-bottom: 20px;
      font-size: 0.82rem;
      color: #666;
    }

    .upload-alt .gdrive-btn {
      background: none;
      border: 1px solid #4285f4;
      color: #4285f4;
      padding: 5px 14px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.82rem;
      font-weight: 600;
      transition: background 0.2s, color 0.2s;
      width: auto;
      margin-left: 6px;
    }

    .upload-alt .gdrive-btn:hover {
      background: #4285f4;
      color: #fff;
    }

    .upload-alt .gdrive-btn:disabled {
      border-color: #555;
      color: #555;
      cursor: not-allowed;
      background: none;
    }

    .gdrive-notice {
      display: none;
      background: rgba(66, 133, 244, 0.1);
      border: 1px solid rgba(66, 133, 244, 0.3);
      border-radius: 8px;
      padding: 10px 14px;
      margin-bottom: 16px;
      font-size: 0.8rem;
      color: #8ab4f8;
      line-height: 1.4;
    }

    .gdrive-notice.active {
      display: block;
    }

    .gdrive-notice code {
      background: rgba(0,0,0,0.3);
      padding: 1px 5px;
      border-radius: 3px;
      font-size: 0.78rem;
    }

    .controls {
      display: flex;
      align-items: center;
      gap: 14px;
      margin-bottom: 24px;
    }

    .controls label {
      font-size: 0.95rem;
      white-space: nowrap;
    }

    .controls input[type="number"] {
      width: 80px;
      padding: 8px 12px;
      border: 1px solid #333;
      border-radius: 6px;
      background: #0f3460;
      color: #e0e0e0;
      font-size: 1rem;
      text-align: center;
    }

    .controls input[type="number"]:focus {
      outline: none;
      border-color: #e94560;
    }

    .hint {
      font-size: 0.8rem;
      color: #666;
    }

    button.action-btn {
      width: 100%;
      padding: 12px;
      border: none;
      border-radius: 8px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s, transform 0.1s;
      background: #e94560;
      color: #fff;
      margin-bottom: 12px;
    }

    button.action-btn:active {
      transform: scale(0.98);
    }

    button.action-btn:hover:not(:disabled) {
      background: #d63851;
    }

    button.action-btn:disabled {
      background: #555;
      cursor: not-allowed;
      transform: none;
    }

    .progress-wrap {
      display: none;
      margin-bottom: 20px;
    }

    .progress-wrap.active {
      display: block;
    }

    .progress-bar {
      width: 100%;
      height: 6px;
      background: #333;
      border-radius: 3px;
      overflow: hidden;
      margin-bottom: 8px;
    }

    .progress-bar .fill {
      height: 100%;
      width: 0%;
      background: #e94560;
      border-radius: 3px;
      transition: width 0.15s;
    }

    .progress-text {
      font-size: 0.85rem;
      color: #aaa;
      text-align: center;
    }

    .result {
      display: none;
      text-align: center;
      margin-top: 16px;
    }

    .result.active {
      display: block;
    }

    .result a {
      display: inline-block;
      padding: 12px 28px;
      background: #4ecca3;
      color: #1a1a2e;
      text-decoration: none;
      border-radius: 8px;
      font-weight: 600;
      font-size: 1rem;
      transition: background 0.2s;
    }

    .result a:hover {
      background: #3db890;
    }

    .result .info {
      margin-top: 10px;
      font-size: 0.82rem;
      color: #888;
    }

    .preview {
      margin-top: 16px;
    }

    .preview audio {
      width: 100%;
      margin-top: 8px;
    }

    .preview-label {
      font-size: 0.85rem;
      color: #888;
    }

    .error {
      display: none;
      background: rgba(233, 69, 96, 0.15);
      border: 1px solid #e94560;
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 16px;
      font-size: 0.9rem;
      color: #e94560;
    }

    .error.active {
      display: block;
    }

    /* ── Set List specific ── */
    .file-list {
      margin-bottom: 20px;
    }

    .file-list-title {
      font-size: 0.9rem;
      color: #aaa;
      margin-bottom: 8px;
    }

    .file-list-items {
      list-style: none;
      max-height: 160px;
      overflow-y: auto;
    }

    .file-list-items li {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 6px 10px;
      border-radius: 4px;
      font-size: 0.85rem;
      color: #ccc;
      background: rgba(15, 52, 96, 0.4);
      margin-bottom: 4px;
    }

    .file-list-items li .remove-btn {
      background: none;
      border: none;
      color: #e94560;
      cursor: pointer;
      font-size: 1rem;
      padding: 0 4px;
      width: auto;
      margin: 0;
      line-height: 1;
    }

    .file-list-items li .remove-btn:hover {
      color: #ff6b81;
    }

    .setlist-slots {
      margin-bottom: 24px;
    }

    .setlist-slots .slot {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
    }

    .slot-number {
      font-size: 0.9rem;
      color: #e94560;
      font-weight: 700;
      min-width: 24px;
      text-align: right;
    }

    .slot select {
      flex: 1;
      padding: 8px 12px;
      border: 1px solid #333;
      border-radius: 6px;
      background: #0f3460;
      color: #e0e0e0;
      font-size: 0.9rem;
      cursor: pointer;
    }

    .slot select:focus {
      outline: none;
      border-color: #e94560;
    }

    /* ── MP3 Editor ── */
    .editor-workspace {
      display: none;
    }

    .editor-workspace.active {
      display: block;
    }

    .waveform-wrap {
      position: relative;
      margin-bottom: 8px;
      user-select: none;
      -webkit-user-select: none;
    }

    .waveform-wrap canvas {
      width: 100%;
      height: 120px;
      display: block;
      border-radius: 6px;
      background: #0a0a1a;
      cursor: crosshair;
    }

    /* Trim overlay regions */
    .trim-overlay-left, .trim-overlay-right {
      position: absolute;
      top: 0;
      height: 100%;
      background: rgba(0, 0, 0, 0.55);
      pointer-events: none;
      border-radius: 6px;
    }

    .trim-overlay-left { left: 0; }
    .trim-overlay-right { right: 0; }

    /* Trim handles */
    .trim-handle {
      position: absolute;
      top: 0;
      width: 8px;
      height: 100%;
      cursor: ew-resize;
      z-index: 5;
    }

    .trim-handle::after {
      content: '';
      position: absolute;
      top: 0;
      width: 3px;
      height: 100%;
      border-radius: 2px;
    }

    .trim-handle-left {
      transform: translateX(-4px);
    }

    .trim-handle-left::after {
      left: 3px;
      background: #4ecca3;
    }

    .trim-handle-right {
      transform: translateX(-4px);
    }

    .trim-handle-right::after {
      right: 3px;
      background: #e94560;
    }

    /* Playhead */
    .playhead {
      position: absolute;
      top: 0;
      width: 2px;
      height: 100%;
      background: #fff;
      pointer-events: none;
      z-index: 4;
      display: none;
    }

    .playhead.active {
      display: block;
    }

    .trim-times {
      display: flex;
      justify-content: space-between;
      font-size: 0.78rem;
      color: #888;
      margin-bottom: 16px;
      padding: 0 2px;
    }

    .trim-times .time-green { color: #4ecca3; }
    .trim-times .time-red   { color: #e94560; }

    .editor-toolbar {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
      flex-wrap: wrap;
    }

    .editor-toolbar button {
      padding: 7px 14px;
      border: 1px solid #333;
      border-radius: 6px;
      background: #0f3460;
      color: #e0e0e0;
      font-size: 0.82rem;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s, border-color 0.2s;
      width: auto;
      margin: 0;
    }

    .editor-toolbar button:hover {
      background: #1a4a8a;
      border-color: #4285f4;
    }

    .editor-toolbar button.active-effect {
      border-color: #4ecca3;
      background: rgba(78, 204, 163, 0.15);
      color: #4ecca3;
    }

    .effect-controls {
      display: none;
      margin-bottom: 20px;
    }

    .effect-controls.active {
      display: block;
    }

    .effect-row {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 10px;
    }

    .effect-row label {
      font-size: 0.85rem;
      min-width: 80px;
      color: #aaa;
    }

    .effect-row input[type="range"] {
      flex: 1;
      accent-color: #e94560;
    }

    .effect-row .range-val {
      font-size: 0.82rem;
      color: #4ecca3;
      min-width: 36px;
      text-align: right;
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Logo (top-right) -->
    <img class="logo" src="MP3 Master Editor.png" alt="MP3 Master Editor" title="MP3 Master Editor">

    <!-- Tab navigation -->
    <div class="tabs">
      <button class="tab-btn active" data-tab="repeater">MP3 Repeater</button>
      <button class="tab-btn" data-tab="setlist">Set List Creator</button>
      <button class="tab-btn" data-tab="editor">MP3 Editor</button>
    </div>

    <!-- ════════════════════════════════════════════ -->
    <!-- Tab 1: MP3 Repeater (original)              -->
    <!-- ════════════════════════════════════════════ -->
    <div class="tab-panel active" id="tab-repeater">
      <h2>MP3 Repeater</h2>
      <p class="subtitle">Upload an MP3, choose how many times it repeats, and download the result.</p>

      <div class="upload-area" id="rpt-uploadArea">
        <input type="file" id="rpt-fileInput" accept=".mp3,audio/mpeg">
        <p class="upload-label">Click or drag an MP3 file here</p>
        <p class="file-name" id="rpt-fileName"></p>
      </div>
      <div class="upload-alt">
        or <button class="gdrive-btn" id="rpt-gdriveBtn" disabled>Import from Google Drive</button>
      </div>

      <div class="gdrive-notice" id="rpt-gdriveNotice"></div>

      <div class="controls">
        <label for="rpt-repeatCount">Total plays:</label>
        <input type="number" id="rpt-repeatCount" min="1" max="50" value="3">
        <span class="hint">e.g. 3 = song plays 3 times</span>
      </div>

      <div class="error" id="rpt-errorBox"></div>

      <button class="action-btn" id="rpt-processBtn" disabled>Select an MP3 first</button>

      <div class="progress-wrap" id="rpt-progressWrap">
        <div class="progress-bar"><div class="fill" id="rpt-progressFill"></div></div>
        <p class="progress-text" id="rpt-progressText">Starting...</p>
      </div>

      <div class="result" id="rpt-result">
        <a id="rpt-downloadLink" href="#" download="repeated.mp3">Download Repeated MP3</a>
        <p class="info" id="rpt-resultInfo"></p>
        <div class="preview">
          <p class="preview-label">Preview:</p>
          <audio id="rpt-audioPreview" controls></audio>
        </div>
      </div>
    </div>

    <!-- ════════════════════════════════════════════ -->
    <!-- Tab 2: Set List Creator                     -->
    <!-- ════════════════════════════════════════════ -->
    <div class="tab-panel" id="tab-setlist">
      <h2>Set List Creator</h2>
      <p class="subtitle">Upload your MP3s, arrange them into a set list, and export as one combined MP3.</p>

      <div class="upload-area" id="sl-uploadArea">
        <input type="file" id="sl-fileInput" accept=".mp3,audio/mpeg" multiple>
        <p class="upload-label">Click or drag MP3 files here (multiple)</p>
        <p class="file-name" id="sl-fileStatus"></p>
      </div>
      <div class="upload-alt">
        or <button class="gdrive-btn" id="sl-gdriveBtn" disabled>Import from Google Drive</button>
      </div>

      <div class="gdrive-notice" id="sl-gdriveNotice"></div>

      <div class="file-list" id="sl-fileList" style="display:none;">
        <p class="file-list-title">Uploaded songs:</p>
        <ul class="file-list-items" id="sl-fileListItems"></ul>
      </div>

      <div class="controls">
        <label for="sl-songCount">Songs in set list:</label>
        <input type="number" id="sl-songCount" min="1" max="100" value="3">
        <button class="action-btn" id="sl-buildSlotsBtn" style="width:auto; padding:8px 16px; margin:0; font-size:0.85rem;">Update slots</button>
      </div>

      <div class="setlist-slots" id="sl-slots"></div>

      <div class="error" id="sl-errorBox"></div>

      <button class="action-btn" id="sl-processBtn" disabled>Upload songs &amp; build set list first</button>

      <div class="progress-wrap" id="sl-progressWrap">
        <div class="progress-bar"><div class="fill" id="sl-progressFill"></div></div>
        <p class="progress-text" id="sl-progressText">Starting...</p>
      </div>

      <div class="result" id="sl-result">
        <a id="sl-downloadLink" href="#" download="setlist.mp3">Download Set List MP3</a>
        <p class="info" id="sl-resultInfo"></p>
        <div class="preview">
          <p class="preview-label">Preview:</p>
          <audio id="sl-audioPreview" controls></audio>
        </div>
      </div>
    </div>

    <!-- ════════════════════════════════════════════ -->
    <!-- Tab 3: MP3 Editor                           -->
    <!-- ════════════════════════════════════════════ -->
    <div class="tab-panel" id="tab-editor">
      <h2>MP3 Editor</h2>
      <p class="subtitle">Trim, crop, and add fade effects to a single MP3.</p>

      <div class="upload-area" id="ed-uploadArea">
        <input type="file" id="ed-fileInput" accept=".mp3,audio/mpeg">
        <p class="upload-label">Click or drag an MP3 file here</p>
        <p class="file-name" id="ed-fileName"></p>
      </div>
      <div class="upload-alt">
        or <button class="gdrive-btn" id="ed-gdriveBtn" disabled>Import from Google Drive</button>
      </div>

      <div class="gdrive-notice" id="ed-gdriveNotice"></div>
      <div class="error" id="ed-errorBox"></div>

      <div class="editor-workspace" id="ed-workspace">
        <!-- Waveform -->
        <div class="waveform-wrap" id="ed-waveformWrap">
          <canvas id="ed-canvas"></canvas>
          <div class="trim-overlay-left" id="ed-overlayLeft"></div>
          <div class="trim-overlay-right" id="ed-overlayRight"></div>
          <div class="trim-handle trim-handle-left" id="ed-handleLeft"></div>
          <div class="trim-handle trim-handle-right" id="ed-handleRight"></div>
          <div class="playhead" id="ed-playhead"></div>
        </div>

        <div class="trim-times">
          <span>Start: <span class="time-green" id="ed-trimStart">0:00.0</span></span>
          <span>Selection: <span id="ed-trimDuration">0:00.0</span></span>
          <span>End: <span class="time-red" id="ed-trimEnd">0:00.0</span></span>
        </div>

        <!-- Toolbar -->
        <div class="editor-toolbar">
          <button id="ed-playBtn">Play selection</button>
          <button id="ed-stopBtn">Stop</button>
          <button id="ed-resetBtn">Reset trim</button>
          <button id="ed-fadeToggle">Fade In/Out</button>
        </div>

        <!-- Fade controls -->
        <div class="effect-controls" id="ed-fadeControls">
          <div class="effect-row">
            <label>Fade in:</label>
            <input type="range" id="ed-fadeIn" min="0" max="10" step="0.1" value="0">
            <span class="range-val" id="ed-fadeInVal">0.0s</span>
          </div>
          <div class="effect-row">
            <label>Fade out:</label>
            <input type="range" id="ed-fadeOut" min="0" max="10" step="0.1" value="0">
            <span class="range-val" id="ed-fadeOutVal">0.0s</span>
          </div>
        </div>

        <!-- Export -->
        <button class="action-btn" id="ed-exportBtn">Export Edited MP3</button>

        <div class="progress-wrap" id="ed-progressWrap">
          <div class="progress-bar"><div class="fill" id="ed-progressFill"></div></div>
          <p class="progress-text" id="ed-progressText">Starting...</p>
        </div>

        <div class="result" id="ed-result">
          <a id="ed-downloadLink" href="#" download="edited.mp3">Download Edited MP3</a>
          <p class="info" id="ed-resultInfo"></p>
          <div class="preview">
            <p class="preview-label">Preview:</p>
            <audio id="ed-audioPreview" controls></audio>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    /* ═══════════════════════════════════════════════
       Google Drive configuration
       ─────────────────────────────────────────────
       To enable Google Drive import, fill in the
       three values below from your Google Cloud
       Console project. Leave them empty to disable.

       Setup steps:
       1. Go to https://console.cloud.google.com
       2. Create a project (or use an existing one)
       3. Enable "Google Picker API" and "Google Drive API"
       4. Create an API Key (Credentials > Create Credentials > API Key)
       5. Create an OAuth 2.0 Client ID (type: Web application)
          - Add your domain to "Authorized JavaScript origins"
            e.g. http://localhost:8080 for local dev
       6. Configure the OAuth consent screen
       7. Paste values below
       ═══════════════════════════════════════════════ */
    const GDRIVE_CLIENT_ID = '';  // e.g. '123456789.apps.googleusercontent.com'
    const GDRIVE_API_KEY   = '';  // e.g. 'AIzaSy...'
    const GDRIVE_APP_ID    = '';  // Your Cloud project number (numeric)

    const GDRIVE_SCOPES = 'https://www.googleapis.com/auth/drive.file';
    const AUDIO_MIMETYPES = 'audio/mpeg,audio/mp3';

    /* ═══════════════════════════════════════════════
       Shared utilities
       ═══════════════════════════════════════════════ */

    function formatSize(bytes) {
      if (bytes < 1024) return bytes + ' B';
      if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';
      return (bytes / 1048576).toFixed(1) + ' MB';
    }

    function showError(el, msg) {
      el.textContent = msg;
      el.classList.add('active');
    }

    function hideError(el) {
      el.classList.remove('active');
    }

    function setProgress(fillEl, textEl, pct, text) {
      fillEl.style.width = pct + '%';
      textEl.textContent = text;
    }

    function floatTo16(floatArr) {
      const int16 = new Int16Array(floatArr.length);
      for (let i = 0; i < floatArr.length; i++) {
        let s = floatArr[i];
        s = s < -1 ? -1 : s > 1 ? 1 : s;
        int16[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
      }
      return int16;
    }

    function encodeMP3(channels, sampleRate, numChannels, totalSamples, progressCb) {
      return new Promise((resolve) => {
        const kbps = 192;
        const encoder = new lamejs.Mp3Encoder(numChannels, sampleRate, kbps);
        const mp3Chunks = [];
        const chunkSize = 1152;

        let offset = 0;
        const isStereo = numChannels >= 2;

        function processChunk() {
          const end = Math.min(offset + chunkSize * 100, totalSamples);

          while (offset < end) {
            const remaining = totalSamples - offset;
            const len = Math.min(chunkSize, remaining);

            const leftF = channels[0].subarray(offset, offset + len);
            const left = floatTo16(leftF);

            let mp3buf;
            if (isStereo) {
              const rightF = channels[1].subarray(offset, offset + len);
              const right = floatTo16(rightF);
              mp3buf = encoder.encodeBuffer(left, right);
            } else {
              mp3buf = encoder.encodeBuffer(left);
            }

            if (mp3buf.length > 0) {
              mp3Chunks.push(mp3buf);
            }
            offset += len;
          }

          if (progressCb) {
            progressCb(offset / totalSamples);
          }

          if (offset < totalSamples) {
            setTimeout(processChunk, 0);
          } else {
            const flush = encoder.flush();
            if (flush.length > 0) {
              mp3Chunks.push(flush);
            }
            resolve(mp3Chunks);
          }
        }

        processChunk();
      });
    }

    /* ═══════════════════════════════════════════════
       Google Drive Picker integration
       ═══════════════════════════════════════════════ */

    const gdriveEnabled = !!(GDRIVE_CLIENT_ID && GDRIVE_API_KEY && GDRIVE_APP_ID);

    let gdrivePickerReady = false;
    let gdriveTokenClient = null;
    let gdriveAccessToken = null;

    function initGoogleDrive() {
      if (!gdriveEnabled) return;

      // Wait for gapi
      function waitGapi() {
        if (typeof gapi !== 'undefined') {
          gapi.load('picker', () => {
            gdrivePickerReady = true;
            enableGdriveButtons();
          });
        } else {
          setTimeout(waitGapi, 200);
        }
      }

      // Wait for GIS (Google Identity Services)
      function waitGis() {
        if (typeof google !== 'undefined' && google.accounts && google.accounts.oauth2) {
          gdriveTokenClient = google.accounts.oauth2.initTokenClient({
            client_id: GDRIVE_CLIENT_ID,
            scope: GDRIVE_SCOPES,
            callback: '', // set before each request
          });
          enableGdriveButtons();
        } else {
          setTimeout(waitGis, 200);
        }
      }

      waitGapi();
      waitGis();
    }

    function enableGdriveButtons() {
      if (!gdrivePickerReady || !gdriveTokenClient) return;
      document.querySelectorAll('.gdrive-btn').forEach(btn => btn.disabled = false);
    }

    /**
     * Open the Google Drive Picker.
     * multiSelect: if true, allow picking multiple files.
     * Returns a promise resolving to an array of { name, blob } objects.
     */
    function openDrivePicker(multiSelect) {
      return new Promise((resolve, reject) => {
        function showPicker() {
          const docsView = new google.picker.DocsView(google.picker.ViewId.DOCS);
          docsView.setIncludeFolders(true);
          docsView.setMimeTypes(AUDIO_MIMETYPES);

          const builder = new google.picker.PickerBuilder()
            .enableFeature(google.picker.Feature.NAV_HIDDEN)
            .setDeveloperKey(GDRIVE_API_KEY)
            .setAppId(GDRIVE_APP_ID)
            .setOAuthToken(gdriveAccessToken)
            .addView(docsView)
            .setTitle('Select MP3 file' + (multiSelect ? 's' : ''))
            .setCallback(async (data) => {
              if (data.action === google.picker.Action.PICKED) {
                try {
                  const docs = data[google.picker.Response.DOCUMENTS];
                  const results = [];
                  for (const doc of docs) {
                    const fileId = doc[google.picker.Document.ID];
                    const fileName = doc[google.picker.Document.NAME];
                    const blob = await downloadDriveFile(fileId);
                    results.push({ name: fileName, blob });
                  }
                  resolve(results);
                } catch (err) {
                  reject(err);
                }
              } else if (data.action === google.picker.Action.CANCEL) {
                resolve([]);
              }
            });

          if (multiSelect) {
            builder.enableFeature(google.picker.Feature.MULTISELECT_ENABLED);
          }

          builder.build().setVisible(true);
        }

        // Get or refresh the OAuth token
        gdriveTokenClient.callback = (tokenResponse) => {
          if (tokenResponse.error) {
            reject(new Error('Google auth error: ' + tokenResponse.error));
            return;
          }
          gdriveAccessToken = tokenResponse.access_token;
          showPicker();
        };

        if (gdriveAccessToken === null) {
          gdriveTokenClient.requestAccessToken({ prompt: 'consent' });
        } else {
          gdriveTokenClient.requestAccessToken({ prompt: '' });
        }
      });
    }

    async function downloadDriveFile(fileId) {
      const url = 'https://www.googleapis.com/drive/v3/files/' + encodeURIComponent(fileId) + '?alt=media';
      const response = await fetch(url, {
        headers: { 'Authorization': 'Bearer ' + gdriveAccessToken },
      });
      if (!response.ok) {
        const text = await response.text();
        throw new Error('Drive download failed (' + response.status + '): ' + text);
      }
      return response.blob();
    }

    // Show setup notice if Drive is not configured
    function showGdriveSetupNotice(noticeEl) {
      if (gdriveEnabled) return;
      noticeEl.innerHTML =
        'Google Drive import is available but needs API keys. ' +
        'Set <code>GDRIVE_CLIENT_ID</code>, <code>GDRIVE_API_KEY</code>, and ' +
        '<code>GDRIVE_APP_ID</code> at the top of the <code>&lt;script&gt;</code> in index.html. ' +
        'See the comments there for setup steps.';
      noticeEl.classList.add('active');
    }

    // Boot Google Drive
    initGoogleDrive();

    /* ═══════════════════════════════════════════════
       Tab switching
       ═══════════════════════════════════════════════ */

    document.querySelectorAll('.tab-btn').forEach((btn) => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
        btn.classList.add('active');
        document.getElementById('tab-' + btn.dataset.tab).classList.add('active');
      });
    });

    /* ═══════════════════════════════════════════════
       Tab 1: MP3 Repeater
       ═══════════════════════════════════════════════ */
    (function repeaterTab() {
      const uploadArea = document.getElementById('rpt-uploadArea');
      const fileInput  = document.getElementById('rpt-fileInput');
      const fileNameEl = document.getElementById('rpt-fileName');
      const repeatInput = document.getElementById('rpt-repeatCount');
      const processBtn = document.getElementById('rpt-processBtn');
      const progressWrap = document.getElementById('rpt-progressWrap');
      const progressFill = document.getElementById('rpt-progressFill');
      const progressTextEl = document.getElementById('rpt-progressText');
      const resultDiv  = document.getElementById('rpt-result');
      const dlLink     = document.getElementById('rpt-downloadLink');
      const resultInfo = document.getElementById('rpt-resultInfo');
      const audioPreview = document.getElementById('rpt-audioPreview');
      const errorBox   = document.getElementById('rpt-errorBox');
      const gdriveBtn  = document.getElementById('rpt-gdriveBtn');
      const gdriveNotice = document.getElementById('rpt-gdriveNotice');

      let selectedFile = null;

      function sp(pct, text) { setProgress(progressFill, progressTextEl, pct, text); }

      showGdriveSetupNotice(gdriveNotice);

      uploadArea.addEventListener('click', () => fileInput.click());
      uploadArea.addEventListener('dragover', (e) => { e.preventDefault(); uploadArea.classList.add('dragover'); });
      uploadArea.addEventListener('dragleave', () => uploadArea.classList.remove('dragover'));
      uploadArea.addEventListener('drop', (e) => {
        e.preventDefault();
        uploadArea.classList.remove('dragover');
        if (e.dataTransfer.files[0]) handleFile(e.dataTransfer.files[0]);
      });
      fileInput.addEventListener('change', () => { if (fileInput.files[0]) handleFile(fileInput.files[0]); });

      // Google Drive import for repeater (single file)
      gdriveBtn.addEventListener('click', async () => {
        try {
          gdriveBtn.disabled = true;
          gdriveBtn.textContent = 'Opening Drive...';
          const results = await openDrivePicker(false);
          if (results.length > 0) {
            const { name, blob } = results[0];
            const file = new File([blob], name, { type: 'audio/mpeg' });
            handleFile(file);
          }
        } catch (err) {
          console.error(err);
          showError(errorBox, 'Google Drive import failed: ' + err.message);
        } finally {
          gdriveBtn.disabled = false;
          gdriveBtn.textContent = 'Import from Google Drive';
        }
      });

      function handleFile(file) {
        if (!file.name.toLowerCase().endsWith('.mp3') && file.type !== 'audio/mpeg') {
          showError(errorBox, 'Please select an MP3 file.');
          return;
        }
        selectedFile = file;
        fileNameEl.textContent = file.name + ' (' + formatSize(file.size) + ')';
        uploadArea.classList.add('has-file');
        processBtn.disabled = false;
        processBtn.textContent = 'Create Repeated MP3';
        resultDiv.classList.remove('active');
        hideError(errorBox);
      }

      processBtn.addEventListener('click', async () => {
        if (!selectedFile) return;
        const repeats = parseInt(repeatInput.value, 10);
        if (isNaN(repeats) || repeats < 1 || repeats > 50) {
          showError(errorBox, 'Please enter a repeat count between 1 and 50.');
          return;
        }

        hideError(errorBox);
        processBtn.disabled = true;
        processBtn.textContent = 'Processing...';
        resultDiv.classList.remove('active');
        progressWrap.classList.add('active');
        sp(5, 'Reading file...');

        try {
          const arrayBuffer = await selectedFile.arrayBuffer();
          sp(15, 'Decoding audio...');

          const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
          audioCtx.close();

          const sampleRate = audioBuffer.sampleRate;
          const numChannels = audioBuffer.numberOfChannels;
          const originalLength = audioBuffer.length;
          const silenceSamples = Math.floor(sampleRate * 0.5);
          const totalLength = originalLength * repeats + silenceSamples * (repeats - 1);

          sp(25, 'Building repeated audio...');

          const channels = [];
          for (let ch = 0; ch < numChannels; ch++) channels.push(audioBuffer.getChannelData(ch));

          const repeatedChannels = [];
          for (let ch = 0; ch < numChannels; ch++) {
            const out = new Float32Array(totalLength);
            let offset = 0;
            for (let r = 0; r < repeats; r++) {
              out.set(channels[ch], offset);
              offset += originalLength;
              if (r < repeats - 1) offset += silenceSamples;
            }
            repeatedChannels.push(out);
          }

          sp(40, 'Encoding to MP3...');

          const mp3Data = await encodeMP3(repeatedChannels, sampleRate, numChannels, totalLength, (ratio) => {
            sp(40 + Math.floor(ratio * 55), 'Encoding to MP3... ' + Math.floor(ratio * 100) + '%');
          });

          sp(95, 'Finalizing...');

          const blob = new Blob(mp3Data, { type: 'audio/mpeg' });
          const url = URL.createObjectURL(blob);
          const baseName = selectedFile.name.replace(/\.mp3$/i, '');
          const outName = baseName + '_x' + repeats + '.mp3';

          dlLink.href = url;
          dlLink.download = outName;
          audioPreview.src = url;

          const durationSec = totalLength / sampleRate;
          resultInfo.textContent = outName + ' \u2014 ' + formatSize(blob.size) + ' \u2014 ' + Math.floor(durationSec / 60) + 'm ' + Math.floor(durationSec % 60) + 's';

          sp(100, 'Done!');
          resultDiv.classList.add('active');
        } catch (err) {
          console.error(err);
          showError(errorBox, 'Error processing audio: ' + err.message);
        } finally {
          processBtn.disabled = false;
          processBtn.textContent = 'Create Repeated MP3';
          setTimeout(() => progressWrap.classList.remove('active'), 1500);
        }
      });
    })();

    /* ═══════════════════════════════════════════════
       Tab 2: Set List Creator
       ═══════════════════════════════════════════════ */
    (function setListTab() {
      const uploadArea  = document.getElementById('sl-uploadArea');
      const fileInput   = document.getElementById('sl-fileInput');
      const fileStatus  = document.getElementById('sl-fileStatus');
      const fileListDiv = document.getElementById('sl-fileList');
      const fileListUl  = document.getElementById('sl-fileListItems');
      const songCountIn = document.getElementById('sl-songCount');
      const buildBtn    = document.getElementById('sl-buildSlotsBtn');
      const slotsDiv    = document.getElementById('sl-slots');
      const processBtn  = document.getElementById('sl-processBtn');
      const progressWrap = document.getElementById('sl-progressWrap');
      const progressFill = document.getElementById('sl-progressFill');
      const progressTextEl = document.getElementById('sl-progressText');
      const resultDiv   = document.getElementById('sl-result');
      const dlLink      = document.getElementById('sl-downloadLink');
      const resultInfo  = document.getElementById('sl-resultInfo');
      const audioPreview = document.getElementById('sl-audioPreview');
      const errorBox    = document.getElementById('sl-errorBox');
      const gdriveBtn   = document.getElementById('sl-gdriveBtn');
      const gdriveNotice = document.getElementById('sl-gdriveNotice');

      let uploadedSongs = new Map();

      function sp(pct, text) { setProgress(progressFill, progressTextEl, pct, text); }

      showGdriveSetupNotice(gdriveNotice);

      /* ── File upload handling ── */
      uploadArea.addEventListener('click', () => fileInput.click());
      uploadArea.addEventListener('dragover', (e) => { e.preventDefault(); uploadArea.classList.add('dragover'); });
      uploadArea.addEventListener('dragleave', () => uploadArea.classList.remove('dragover'));
      uploadArea.addEventListener('drop', (e) => {
        e.preventDefault();
        uploadArea.classList.remove('dragover');
        handleFiles(e.dataTransfer.files);
      });
      fileInput.addEventListener('change', () => handleFiles(fileInput.files));

      // Google Drive import for set list (multi-select)
      gdriveBtn.addEventListener('click', async () => {
        try {
          gdriveBtn.disabled = true;
          gdriveBtn.textContent = 'Opening Drive...';
          const results = await openDrivePicker(true);
          if (results.length > 0) {
            for (const { name, blob } of results) {
              const file = new File([blob], name, { type: 'audio/mpeg' });
              uploadedSongs.set(file.name, file);
            }
            hideError(errorBox);
            refreshFileList();
            refreshSlotDropdowns();
            uploadArea.classList.add('has-file');
            fileStatus.textContent = uploadedSongs.size + ' song' + (uploadedSongs.size !== 1 ? 's' : '') + ' loaded';
            updateProcessBtnState();
          }
        } catch (err) {
          console.error(err);
          showError(errorBox, 'Google Drive import failed: ' + err.message);
        } finally {
          gdriveBtn.disabled = false;
          gdriveBtn.textContent = 'Import from Google Drive';
        }
      });

      function handleFiles(files) {
        let added = 0;
        for (const file of files) {
          if (file.name.toLowerCase().endsWith('.mp3') || file.type === 'audio/mpeg') {
            uploadedSongs.set(file.name, file);
            added++;
          }
        }
        if (added === 0) {
          showError(errorBox, 'No MP3 files found in selection.');
          return;
        }
        hideError(errorBox);
        refreshFileList();
        refreshSlotDropdowns();
        uploadArea.classList.add('has-file');
        fileStatus.textContent = uploadedSongs.size + ' song' + (uploadedSongs.size !== 1 ? 's' : '') + ' loaded';
        updateProcessBtnState();
      }

      function refreshFileList() {
        fileListUl.innerHTML = '';
        if (uploadedSongs.size === 0) {
          fileListDiv.style.display = 'none';
          return;
        }
        fileListDiv.style.display = 'block';
        for (const [name, file] of uploadedSongs) {
          const li = document.createElement('li');

          const span = document.createElement('span');
          span.textContent = name + ' (' + formatSize(file.size) + ')';
          li.appendChild(span);

          const removeBtn = document.createElement('button');
          removeBtn.className = 'remove-btn';
          removeBtn.textContent = '\u00d7';
          removeBtn.title = 'Remove';
          removeBtn.addEventListener('click', () => {
            uploadedSongs.delete(name);
            refreshFileList();
            refreshSlotDropdowns();
            fileStatus.textContent = uploadedSongs.size + ' song' + (uploadedSongs.size !== 1 ? 's' : '') + ' loaded';
            if (uploadedSongs.size === 0) {
              uploadArea.classList.remove('has-file');
              fileStatus.textContent = '';
            }
            updateProcessBtnState();
          });
          li.appendChild(removeBtn);
          fileListUl.appendChild(li);
        }
      }

      /* ── Slot management ── */
      function buildSlots() {
        const count = parseInt(songCountIn.value, 10);
        if (isNaN(count) || count < 1 || count > 100) {
          showError(errorBox, 'Enter a set list size between 1 and 100.');
          return;
        }
        hideError(errorBox);

        const existing = [];
        slotsDiv.querySelectorAll('select').forEach(sel => existing.push(sel.value));

        slotsDiv.innerHTML = '';
        const names = [...uploadedSongs.keys()];

        for (let i = 0; i < count; i++) {
          const slot = document.createElement('div');
          slot.className = 'slot';

          const num = document.createElement('span');
          num.className = 'slot-number';
          num.textContent = (i + 1) + '.';
          slot.appendChild(num);

          const select = document.createElement('select');
          select.dataset.slot = i;

          const placeholder = document.createElement('option');
          placeholder.value = '';
          placeholder.textContent = '\u2014 choose a song \u2014';
          select.appendChild(placeholder);

          names.forEach((name) => {
            const opt = document.createElement('option');
            opt.value = name;
            opt.textContent = name.replace(/\.mp3$/i, '');
            select.appendChild(opt);
          });

          if (existing[i] && uploadedSongs.has(existing[i])) {
            select.value = existing[i];
          } else if (names[i]) {
            select.value = names[i];
          }

          slot.appendChild(select);
          slotsDiv.appendChild(slot);
        }
        updateProcessBtnState();
      }

      function refreshSlotDropdowns() {
        const names = [...uploadedSongs.keys()];
        slotsDiv.querySelectorAll('select').forEach((select) => {
          const current = select.value;
          while (select.options.length > 1) select.remove(1);

          names.forEach((name) => {
            const opt = document.createElement('option');
            opt.value = name;
            opt.textContent = name.replace(/\.mp3$/i, '');
            select.appendChild(opt);
          });

          if (uploadedSongs.has(current)) {
            select.value = current;
          } else {
            select.value = '';
          }
        });
        updateProcessBtnState();
      }

      buildBtn.addEventListener('click', buildSlots);
      songCountIn.addEventListener('change', buildSlots);

      buildSlots();

      function updateProcessBtnState() {
        const selects = slotsDiv.querySelectorAll('select');
        const allFilled = selects.length > 0 && [...selects].every(s => s.value !== '');
        const hasSongs = uploadedSongs.size > 0;

        if (!hasSongs) {
          processBtn.disabled = true;
          processBtn.textContent = 'Upload songs first';
        } else if (!allFilled) {
          processBtn.disabled = true;
          processBtn.textContent = 'Fill all set list slots';
        } else {
          processBtn.disabled = false;
          processBtn.textContent = 'Create Set List MP3';
        }
      }

      /* ── Processing ── */
      processBtn.addEventListener('click', async () => {
        const selects = slotsDiv.querySelectorAll('select');
        const songOrder = [...selects].map(s => s.value);

        if (songOrder.some(n => !n || !uploadedSongs.has(n))) {
          showError(errorBox, 'Please fill every slot with a song.');
          return;
        }

        hideError(errorBox);
        processBtn.disabled = true;
        processBtn.textContent = 'Processing...';
        resultDiv.classList.remove('active');
        progressWrap.classList.add('active');
        sp(2, 'Reading files...');

        try {
          const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

          const decodedCache = new Map();
          const uniqueNames = [...new Set(songOrder)];

          for (let i = 0; i < uniqueNames.length; i++) {
            const name = uniqueNames[i];
            sp(2 + Math.floor((i / uniqueNames.length) * 20), 'Decoding: ' + name.replace(/\.mp3$/i, '') + '...');
            const buf = await uploadedSongs.get(name).arrayBuffer();
            const decoded = await audioCtx.decodeAudioData(buf);
            decodedCache.set(name, decoded);
          }

          audioCtx.close();

          sp(25, 'Building set list...');

          const firstBuffer = decodedCache.get(songOrder[0]);
          const sampleRate = firstBuffer.sampleRate;
          const numChannels = Math.max(...[...decodedCache.values()].map(b => b.numberOfChannels));

          const silenceSamples = Math.floor(sampleRate * 1.0);

          let totalLength = 0;
          for (let i = 0; i < songOrder.length; i++) {
            totalLength += decodedCache.get(songOrder[i]).length;
            if (i < songOrder.length - 1) totalLength += silenceSamples;
          }

          const combined = [];
          for (let ch = 0; ch < numChannels; ch++) {
            const out = new Float32Array(totalLength);
            let offset = 0;
            for (let i = 0; i < songOrder.length; i++) {
              const buf = decodedCache.get(songOrder[i]);
              const srcCh = ch < buf.numberOfChannels ? ch : 0;
              const data = buf.getChannelData(srcCh);
              out.set(data, offset);
              offset += buf.length;
              if (i < songOrder.length - 1) offset += silenceSamples;
            }
            combined.push(out);
          }

          sp(35, 'Encoding to MP3...');

          const mp3Data = await encodeMP3(combined, sampleRate, numChannels, totalLength, (ratio) => {
            sp(35 + Math.floor(ratio * 60), 'Encoding to MP3... ' + Math.floor(ratio * 100) + '%');
          });

          sp(96, 'Finalizing...');

          const blob = new Blob(mp3Data, { type: 'audio/mpeg' });
          const url = URL.createObjectURL(blob);
          const outName = 'setlist_' + songOrder.length + '_songs.mp3';

          dlLink.href = url;
          dlLink.download = outName;
          audioPreview.src = url;

          const durationSec = totalLength / sampleRate;
          const mins = Math.floor(durationSec / 60);
          const secs = Math.floor(durationSec % 60);
          resultInfo.textContent = outName + ' \u2014 ' + formatSize(blob.size) + ' \u2014 ' + mins + 'm ' + secs + 's \u2014 ' + songOrder.length + ' songs';

          sp(100, 'Done!');
          resultDiv.classList.add('active');
        } catch (err) {
          console.error(err);
          showError(errorBox, 'Error processing audio: ' + err.message);
        } finally {
          processBtn.disabled = false;
          processBtn.textContent = 'Create Set List MP3';
          setTimeout(() => progressWrap.classList.remove('active'), 1500);
        }
      });
    })();

    /* ═══════════════════════════════════════════════
       Tab 3: MP3 Editor
       ═══════════════════════════════════════════════ */
    (function editorTab() {
      const uploadArea  = document.getElementById('ed-uploadArea');
      const fileInput   = document.getElementById('ed-fileInput');
      const fileNameEl  = document.getElementById('ed-fileName');
      const errorBox    = document.getElementById('ed-errorBox');
      const gdriveBtn   = document.getElementById('ed-gdriveBtn');
      const gdriveNotice = document.getElementById('ed-gdriveNotice');
      const workspace   = document.getElementById('ed-workspace');
      const canvas      = document.getElementById('ed-canvas');
      const ctx         = canvas.getContext('2d');
      const waveformWrap = document.getElementById('ed-waveformWrap');
      const overlayLeft  = document.getElementById('ed-overlayLeft');
      const overlayRight = document.getElementById('ed-overlayRight');
      const handleLeft   = document.getElementById('ed-handleLeft');
      const handleRight  = document.getElementById('ed-handleRight');
      const playhead     = document.getElementById('ed-playhead');
      const trimStartEl  = document.getElementById('ed-trimStart');
      const trimEndEl    = document.getElementById('ed-trimEnd');
      const trimDurEl    = document.getElementById('ed-trimDuration');
      const playBtn      = document.getElementById('ed-playBtn');
      const stopBtn      = document.getElementById('ed-stopBtn');
      const resetBtn     = document.getElementById('ed-resetBtn');
      const fadeToggle   = document.getElementById('ed-fadeToggle');
      const fadeControls = document.getElementById('ed-fadeControls');
      const fadeInRange  = document.getElementById('ed-fadeIn');
      const fadeOutRange = document.getElementById('ed-fadeOut');
      const fadeInVal    = document.getElementById('ed-fadeInVal');
      const fadeOutVal   = document.getElementById('ed-fadeOutVal');
      const exportBtn    = document.getElementById('ed-exportBtn');
      const progressWrap = document.getElementById('ed-progressWrap');
      const progressFill = document.getElementById('ed-progressFill');
      const progressTextEl = document.getElementById('ed-progressText');
      const resultDiv    = document.getElementById('ed-result');
      const dlLink       = document.getElementById('ed-downloadLink');
      const resultInfo   = document.getElementById('ed-resultInfo');
      const audioPreview = document.getElementById('ed-audioPreview');

      let audioBuffer = null;
      let sampleRate = 44100;
      let duration = 0;
      let fileName = '';

      // Trim state: ratio 0..1 within the full track
      let trimStartRatio = 0;
      let trimEndRatio = 1;

      // Playback state
      let playCtx = null;
      let playSource = null;
      let playStartTime = 0;
      let playStartOffset = 0;
      let playAnimId = null;

      function sp(pct, text) { setProgress(progressFill, progressTextEl, pct, text); }

      showGdriveSetupNotice(gdriveNotice);

      /* ── File upload ── */
      uploadArea.addEventListener('click', () => fileInput.click());
      uploadArea.addEventListener('dragover', (e) => { e.preventDefault(); uploadArea.classList.add('dragover'); });
      uploadArea.addEventListener('dragleave', () => uploadArea.classList.remove('dragover'));
      uploadArea.addEventListener('drop', (e) => {
        e.preventDefault();
        uploadArea.classList.remove('dragover');
        if (e.dataTransfer.files[0]) loadFile(e.dataTransfer.files[0]);
      });
      fileInput.addEventListener('change', () => { if (fileInput.files[0]) loadFile(fileInput.files[0]); });

      gdriveBtn.addEventListener('click', async () => {
        try {
          gdriveBtn.disabled = true;
          gdriveBtn.textContent = 'Opening Drive...';
          const results = await openDrivePicker(false);
          if (results.length > 0) {
            const { name, blob } = results[0];
            loadFile(new File([blob], name, { type: 'audio/mpeg' }));
          }
        } catch (err) {
          showError(errorBox, 'Google Drive import failed: ' + err.message);
        } finally {
          gdriveBtn.disabled = false;
          gdriveBtn.textContent = 'Import from Google Drive';
        }
      });

      async function loadFile(file) {
        if (!file.name.toLowerCase().endsWith('.mp3') && file.type !== 'audio/mpeg') {
          showError(errorBox, 'Please select an MP3 file.');
          return;
        }
        hideError(errorBox);
        fileName = file.name;
        fileNameEl.textContent = file.name + ' (' + formatSize(file.size) + ')';
        uploadArea.classList.add('has-file');

        try {
          const arrayBuf = await file.arrayBuffer();
          const actx = new (window.AudioContext || window.webkitAudioContext)();
          audioBuffer = await actx.decodeAudioData(arrayBuf);
          actx.close();

          sampleRate = audioBuffer.sampleRate;
          duration = audioBuffer.duration;

          trimStartRatio = 0;
          trimEndRatio = 1;

          workspace.classList.add('active');
          resultDiv.classList.remove('active');

          drawWaveform();
          updateTrimUI();
        } catch (err) {
          console.error(err);
          showError(errorBox, 'Failed to decode audio: ' + err.message);
        }
      }

      /* ── Waveform drawing ── */
      function drawWaveform() {
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);

        const w = rect.width;
        const h = rect.height;
        const mid = h / 2;
        const data = audioBuffer.getChannelData(0);
        const step = Math.max(1, Math.floor(data.length / w));

        ctx.clearRect(0, 0, w, h);

        // Draw center line
        ctx.strokeStyle = '#1a3a5c';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, mid);
        ctx.lineTo(w, mid);
        ctx.stroke();

        // Draw waveform
        ctx.fillStyle = '#e94560';
        for (let x = 0; x < w; x++) {
          const start = Math.floor(x * data.length / w);
          let min = 0, max = 0;
          for (let j = 0; j < step; j++) {
            const val = data[start + j] || 0;
            if (val < min) min = val;
            if (val > max) max = val;
          }
          const top = mid + min * mid;
          const bottom = mid + max * mid;
          ctx.fillRect(x, top, 1, bottom - top || 1);
        }

        // Time markers at bottom
        ctx.fillStyle = '#555';
        ctx.font = '10px sans-serif';
        const numMarkers = Math.min(10, Math.floor(duration));
        if (numMarkers > 0) {
          const interval = duration / numMarkers;
          for (let i = 0; i <= numMarkers; i++) {
            const t = i * interval;
            const x = (t / duration) * w;
            ctx.fillRect(x, h - 12, 1, 4);
            ctx.fillText(fmtTime(t), x + 2, h - 2);
          }
        }
      }

      /* ── Time formatting ── */
      function fmtTime(sec) {
        const m = Math.floor(sec / 60);
        const s = sec % 60;
        return m + ':' + s.toFixed(1).padStart(4, '0');
      }

      /* ── Trim handle dragging ── */
      function updateTrimUI() {
        const w = waveformWrap.getBoundingClientRect().width;

        overlayLeft.style.width = (trimStartRatio * 100) + '%';
        overlayRight.style.width = ((1 - trimEndRatio) * 100) + '%';

        handleLeft.style.left = (trimStartRatio * 100) + '%';
        handleRight.style.left = (trimEndRatio * 100) + '%';

        const startSec = trimStartRatio * duration;
        const endSec = trimEndRatio * duration;
        trimStartEl.textContent = fmtTime(startSec);
        trimEndEl.textContent = fmtTime(endSec);
        trimDurEl.textContent = fmtTime(endSec - startSec);
      }

      function startDrag(handle, isLeft) {
        const onMove = (e) => {
          e.preventDefault();
          const rect = waveformWrap.getBoundingClientRect();
          const clientX = e.touches ? e.touches[0].clientX : e.clientX;
          let ratio = (clientX - rect.left) / rect.width;
          ratio = Math.max(0, Math.min(1, ratio));

          if (isLeft) {
            trimStartRatio = Math.min(ratio, trimEndRatio - 0.005);
          } else {
            trimEndRatio = Math.max(ratio, trimStartRatio + 0.005);
          }
          updateTrimUI();
        };

        const onUp = () => {
          document.removeEventListener('mousemove', onMove);
          document.removeEventListener('mouseup', onUp);
          document.removeEventListener('touchmove', onMove);
          document.removeEventListener('touchend', onUp);
        };

        document.addEventListener('mousemove', onMove);
        document.addEventListener('mouseup', onUp);
        document.addEventListener('touchmove', onMove, { passive: false });
        document.addEventListener('touchend', onUp);
      }

      handleLeft.addEventListener('mousedown', (e) => { e.preventDefault(); startDrag(handleLeft, true); });
      handleLeft.addEventListener('touchstart', (e) => { e.preventDefault(); startDrag(handleLeft, true); }, { passive: false });
      handleRight.addEventListener('mousedown', (e) => { e.preventDefault(); startDrag(handleRight, false); });
      handleRight.addEventListener('touchstart', (e) => { e.preventDefault(); startDrag(handleRight, false); }, { passive: false });

      // Click on waveform to set playhead position
      canvas.addEventListener('click', (e) => {
        const rect = canvas.getBoundingClientRect();
        const ratio = (e.clientX - rect.left) / rect.width;
        // If clicked outside trim range, move nearest handle
        if (ratio < trimStartRatio) {
          trimStartRatio = Math.max(0, ratio);
          updateTrimUI();
        } else if (ratio > trimEndRatio) {
          trimEndRatio = Math.min(1, ratio);
          updateTrimUI();
        }
      });

      /* ── Reset trim ── */
      resetBtn.addEventListener('click', () => {
        trimStartRatio = 0;
        trimEndRatio = 1;
        updateTrimUI();
      });

      /* ── Fade toggle ── */
      fadeToggle.addEventListener('click', () => {
        fadeToggle.classList.toggle('active-effect');
        fadeControls.classList.toggle('active');
      });

      fadeInRange.addEventListener('input', () => {
        fadeInVal.textContent = parseFloat(fadeInRange.value).toFixed(1) + 's';
      });
      fadeOutRange.addEventListener('input', () => {
        fadeOutVal.textContent = parseFloat(fadeOutRange.value).toFixed(1) + 's';
      });

      /* ── Playback ── */
      function stopPlayback() {
        if (playSource) {
          try { playSource.stop(); } catch (_) {}
          playSource = null;
        }
        if (playCtx) {
          playCtx.close();
          playCtx = null;
        }
        if (playAnimId) {
          cancelAnimationFrame(playAnimId);
          playAnimId = null;
        }
        playhead.classList.remove('active');
      }

      playBtn.addEventListener('click', () => {
        if (!audioBuffer) return;
        stopPlayback();

        playCtx = new (window.AudioContext || window.webkitAudioContext)();

        const startSample = Math.floor(trimStartRatio * audioBuffer.length);
        const endSample = Math.floor(trimEndRatio * audioBuffer.length);
        const len = endSample - startSample;
        if (len <= 0) return;

        // Create a buffer with just the trimmed region (with fades applied for preview)
        const numCh = audioBuffer.numberOfChannels;
        const previewBuf = playCtx.createBuffer(numCh, len, audioBuffer.sampleRate);

        const fadeInSec = parseFloat(fadeInRange.value) || 0;
        const fadeOutSec = parseFloat(fadeOutRange.value) || 0;
        const fadeInSamples = Math.floor(fadeInSec * audioBuffer.sampleRate);
        const fadeOutSamples = Math.floor(fadeOutSec * audioBuffer.sampleRate);

        for (let ch = 0; ch < numCh; ch++) {
          const src = audioBuffer.getChannelData(ch);
          const dst = previewBuf.getChannelData(ch);
          for (let i = 0; i < len; i++) {
            let sample = src[startSample + i];
            // Fade in
            if (i < fadeInSamples) {
              sample *= i / fadeInSamples;
            }
            // Fade out
            if (i >= len - fadeOutSamples) {
              sample *= (len - i) / fadeOutSamples;
            }
            dst[i] = sample;
          }
        }

        playSource = playCtx.createBufferSource();
        playSource.buffer = previewBuf;
        playSource.connect(playCtx.destination);
        playSource.start();

        playStartTime = playCtx.currentTime;
        playStartOffset = trimStartRatio;
        const selectionDuration = (trimEndRatio - trimStartRatio) * duration;

        playhead.classList.add('active');

        function animatePlayhead() {
          if (!playCtx) return;
          const elapsed = playCtx.currentTime - playStartTime;
          if (elapsed >= selectionDuration) {
            stopPlayback();
            return;
          }
          const ratio = playStartOffset + (elapsed / duration);
          playhead.style.left = (ratio * 100) + '%';
          playAnimId = requestAnimationFrame(animatePlayhead);
        }
        animatePlayhead();

        playSource.onended = () => stopPlayback();
      });

      stopBtn.addEventListener('click', stopPlayback);

      /* ── Export ── */
      exportBtn.addEventListener('click', async () => {
        if (!audioBuffer) return;

        hideError(errorBox);
        exportBtn.disabled = true;
        exportBtn.textContent = 'Exporting...';
        resultDiv.classList.remove('active');
        progressWrap.classList.add('active');
        sp(5, 'Preparing audio...');

        try {
          const startSample = Math.floor(trimStartRatio * audioBuffer.length);
          const endSample = Math.floor(trimEndRatio * audioBuffer.length);
          const len = endSample - startSample;
          const numCh = audioBuffer.numberOfChannels;

          const fadeInSec = parseFloat(fadeInRange.value) || 0;
          const fadeOutSec = parseFloat(fadeOutRange.value) || 0;
          const fadeInSamples = Math.floor(fadeInSec * sampleRate);
          const fadeOutSamples = Math.floor(fadeOutSec * sampleRate);

          sp(15, 'Applying effects...');

          const channels = [];
          for (let ch = 0; ch < numCh; ch++) {
            const src = audioBuffer.getChannelData(ch);
            const dst = new Float32Array(len);
            for (let i = 0; i < len; i++) {
              let sample = src[startSample + i];
              if (i < fadeInSamples) {
                sample *= i / fadeInSamples;
              }
              if (i >= len - fadeOutSamples) {
                sample *= (len - i) / fadeOutSamples;
              }
              dst[i] = sample;
            }
            channels.push(dst);
          }

          sp(30, 'Encoding to MP3...');

          const mp3Data = await encodeMP3(channels, sampleRate, numCh, len, (ratio) => {
            sp(30 + Math.floor(ratio * 65), 'Encoding to MP3... ' + Math.floor(ratio * 100) + '%');
          });

          sp(96, 'Finalizing...');

          const blob = new Blob(mp3Data, { type: 'audio/mpeg' });
          const url = URL.createObjectURL(blob);
          const baseName = fileName.replace(/\.mp3$/i, '');
          const outName = baseName + '_edited.mp3';

          dlLink.href = url;
          dlLink.download = outName;
          audioPreview.src = url;

          const durationSec = len / sampleRate;
          const mins = Math.floor(durationSec / 60);
          const secs = Math.floor(durationSec % 60);
          resultInfo.textContent = outName + ' \u2014 ' + formatSize(blob.size) + ' \u2014 ' + mins + 'm ' + secs + 's';

          sp(100, 'Done!');
          resultDiv.classList.add('active');
        } catch (err) {
          console.error(err);
          showError(errorBox, 'Export failed: ' + err.message);
        } finally {
          exportBtn.disabled = false;
          exportBtn.textContent = 'Export Edited MP3';
          setTimeout(() => progressWrap.classList.remove('active'), 1500);
        }
      });

      /* ── Redraw on resize ── */
      let resizeTimer;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(() => {
          if (audioBuffer) {
            drawWaveform();
            updateTrimUI();
          }
        }, 150);
      });
    })();
  </script>
</body>
</html>
