<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MP3 Tools</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lamejs/1.2.1/lame.min.js"></script>
  <!-- Google APIs for Drive Picker -->
  <script src="https://apis.google.com/js/api.js" async defer></script>
  <script src="https://accounts.google.com/gsi/client" async defer></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #1a1a2e;
      color: #e0e0e0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .container {
      background: #16213e;
      border-radius: 12px;
      padding: 40px;
      max-width: 600px;
      width: 100%;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      position: relative;
    }

    /* ── Logo ── */
    .logo {
      position: absolute;
      top: 16px;
      right: 16px;
      max-width: 80px;
      max-height: 80px;
      border-radius: 8px;
      object-fit: contain;
    }

    /* ── Tabs ── */
    .tabs {
      display: flex;
      gap: 4px;
      margin-bottom: 28px;
      border-bottom: 2px solid #0f3460;
      padding-bottom: 0;
      padding-right: 90px;
    }

    .tab-btn {
      flex: 1;
      padding: 10px 16px;
      border: none;
      border-bottom: 3px solid transparent;
      border-radius: 8px 8px 0 0;
      background: transparent;
      color: #888;
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
      transition: color 0.2s, border-color 0.2s, background 0.2s;
      width: auto;
    }

    .tab-btn:hover {
      color: #ccc;
      background: rgba(233, 69, 96, 0.05);
    }

    .tab-btn.active {
      color: #e94560;
      border-bottom-color: #e94560;
      background: rgba(233, 69, 96, 0.08);
    }

    .tab-panel {
      display: none;
    }

    .tab-panel.active {
      display: block;
    }

    /* ── Shared styles ── */
    h2 {
      font-size: 1.4rem;
      margin-bottom: 6px;
      color: #e94560;
    }

    .subtitle {
      font-size: 0.9rem;
      color: #888;
      margin-bottom: 24px;
    }

    .upload-area {
      border: 2px dashed #333;
      border-radius: 8px;
      padding: 32px;
      text-align: center;
      cursor: pointer;
      transition: border-color 0.2s, background 0.2s;
      margin-bottom: 10px;
    }

    .upload-area:hover, .upload-area.dragover {
      border-color: #e94560;
      background: rgba(233, 69, 96, 0.05);
    }

    .upload-area.has-file {
      border-color: #4ecca3;
      background: rgba(78, 204, 163, 0.05);
    }

    .upload-area input[type="file"] {
      display: none;
    }

    .upload-label {
      font-size: 0.95rem;
      color: #aaa;
    }

    .file-name {
      margin-top: 8px;
      font-size: 0.85rem;
      color: #4ecca3;
      word-break: break-all;
    }

    .upload-alt {
      text-align: center;
      margin-bottom: 20px;
      font-size: 0.82rem;
      color: #666;
    }

    .upload-alt .gdrive-btn {
      background: none;
      border: 1px solid #4285f4;
      color: #4285f4;
      padding: 5px 14px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.82rem;
      font-weight: 600;
      transition: background 0.2s, color 0.2s;
      width: auto;
      margin-left: 6px;
    }

    .upload-alt .gdrive-btn:hover {
      background: #4285f4;
      color: #fff;
    }

    .upload-alt .gdrive-btn:disabled {
      border-color: #555;
      color: #555;
      cursor: not-allowed;
      background: none;
    }

    .gdrive-notice {
      display: none;
      background: rgba(66, 133, 244, 0.1);
      border: 1px solid rgba(66, 133, 244, 0.3);
      border-radius: 8px;
      padding: 10px 14px;
      margin-bottom: 16px;
      font-size: 0.8rem;
      color: #8ab4f8;
      line-height: 1.4;
    }

    .gdrive-notice.active {
      display: block;
    }

    .gdrive-notice code {
      background: rgba(0,0,0,0.3);
      padding: 1px 5px;
      border-radius: 3px;
      font-size: 0.78rem;
    }

    .controls {
      display: flex;
      align-items: center;
      gap: 14px;
      margin-bottom: 24px;
    }

    .controls label {
      font-size: 0.95rem;
      white-space: nowrap;
    }

    .controls input[type="number"] {
      width: 80px;
      padding: 8px 12px;
      border: 1px solid #333;
      border-radius: 6px;
      background: #0f3460;
      color: #e0e0e0;
      font-size: 1rem;
      text-align: center;
    }

    .controls input[type="number"]:focus {
      outline: none;
      border-color: #e94560;
    }

    .hint {
      font-size: 0.8rem;
      color: #666;
    }

    button.action-btn {
      width: 100%;
      padding: 12px;
      border: none;
      border-radius: 8px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s, transform 0.1s;
      background: #e94560;
      color: #fff;
      margin-bottom: 12px;
    }

    button.action-btn:active {
      transform: scale(0.98);
    }

    button.action-btn:hover:not(:disabled) {
      background: #d63851;
    }

    button.action-btn:disabled {
      background: #555;
      cursor: not-allowed;
      transform: none;
    }

    .progress-wrap {
      display: none;
      margin-bottom: 20px;
    }

    .progress-wrap.active {
      display: block;
    }

    .progress-bar {
      width: 100%;
      height: 6px;
      background: #333;
      border-radius: 3px;
      overflow: hidden;
      margin-bottom: 8px;
    }

    .progress-bar .fill {
      height: 100%;
      width: 0%;
      background: #e94560;
      border-radius: 3px;
      transition: width 0.15s;
    }

    .progress-text {
      font-size: 0.85rem;
      color: #aaa;
      text-align: center;
    }

    .result {
      display: none;
      text-align: center;
      margin-top: 16px;
    }

    .result.active {
      display: block;
    }

    .result a {
      display: inline-block;
      padding: 12px 28px;
      background: #4ecca3;
      color: #1a1a2e;
      text-decoration: none;
      border-radius: 8px;
      font-weight: 600;
      font-size: 1rem;
      transition: background 0.2s;
    }

    .result a:hover {
      background: #3db890;
    }

    .result .info {
      margin-top: 10px;
      font-size: 0.82rem;
      color: #888;
    }

    .preview {
      margin-top: 16px;
    }

    .preview audio {
      width: 100%;
      margin-top: 8px;
    }

    .preview-label {
      font-size: 0.85rem;
      color: #888;
    }

    .error {
      display: none;
      background: rgba(233, 69, 96, 0.15);
      border: 1px solid #e94560;
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 16px;
      font-size: 0.9rem;
      color: #e94560;
    }

    .error.active {
      display: block;
    }

    /* ── Set List specific ── */
    .file-list {
      margin-bottom: 20px;
    }

    .file-list-title {
      font-size: 0.9rem;
      color: #aaa;
      margin-bottom: 8px;
    }

    .file-list-items {
      list-style: none;
      max-height: 160px;
      overflow-y: auto;
    }

    .file-list-items li {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 6px 10px;
      border-radius: 4px;
      font-size: 0.85rem;
      color: #ccc;
      background: rgba(15, 52, 96, 0.4);
      margin-bottom: 4px;
    }

    .file-list-items li .remove-btn {
      background: none;
      border: none;
      color: #e94560;
      cursor: pointer;
      font-size: 1rem;
      padding: 0 4px;
      width: auto;
      margin: 0;
      line-height: 1;
    }

    .file-list-items li .remove-btn:hover {
      color: #ff6b81;
    }

    .setlist-slots {
      margin-bottom: 24px;
    }

    .setlist-slots .slot {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
    }

    .slot-number {
      font-size: 0.9rem;
      color: #e94560;
      font-weight: 700;
      min-width: 24px;
      text-align: right;
    }

    .slot select {
      flex: 1;
      padding: 8px 12px;
      border: 1px solid #333;
      border-radius: 6px;
      background: #0f3460;
      color: #e0e0e0;
      font-size: 0.9rem;
      cursor: pointer;
    }

    .slot select:focus {
      outline: none;
      border-color: #e94560;
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Logo (top-right) -->
    <img class="logo" src="MP3 Master Editor.png" alt="MP3 Master Editor" title="MP3 Master Editor">

    <!-- Tab navigation -->
    <div class="tabs">
      <button class="tab-btn active" data-tab="repeater">MP3 Repeater</button>
      <button class="tab-btn" data-tab="setlist">Set List Creator</button>
    </div>

    <!-- ════════════════════════════════════════════ -->
    <!-- Tab 1: MP3 Repeater (original)              -->
    <!-- ════════════════════════════════════════════ -->
    <div class="tab-panel active" id="tab-repeater">
      <h2>MP3 Repeater</h2>
      <p class="subtitle">Upload an MP3, choose how many times it repeats, and download the result.</p>

      <div class="upload-area" id="rpt-uploadArea">
        <input type="file" id="rpt-fileInput" accept=".mp3,audio/mpeg">
        <p class="upload-label">Click or drag an MP3 file here</p>
        <p class="file-name" id="rpt-fileName"></p>
      </div>
      <div class="upload-alt">
        or <button class="gdrive-btn" id="rpt-gdriveBtn" disabled>Import from Google Drive</button>
      </div>

      <div class="gdrive-notice" id="rpt-gdriveNotice"></div>

      <div class="controls">
        <label for="rpt-repeatCount">Total plays:</label>
        <input type="number" id="rpt-repeatCount" min="1" max="50" value="3">
        <span class="hint">e.g. 3 = song plays 3 times</span>
      </div>

      <div class="error" id="rpt-errorBox"></div>

      <button class="action-btn" id="rpt-processBtn" disabled>Select an MP3 first</button>

      <div class="progress-wrap" id="rpt-progressWrap">
        <div class="progress-bar"><div class="fill" id="rpt-progressFill"></div></div>
        <p class="progress-text" id="rpt-progressText">Starting...</p>
      </div>

      <div class="result" id="rpt-result">
        <a id="rpt-downloadLink" href="#" download="repeated.mp3">Download Repeated MP3</a>
        <p class="info" id="rpt-resultInfo"></p>
        <div class="preview">
          <p class="preview-label">Preview:</p>
          <audio id="rpt-audioPreview" controls></audio>
        </div>
      </div>
    </div>

    <!-- ════════════════════════════════════════════ -->
    <!-- Tab 2: Set List Creator                     -->
    <!-- ════════════════════════════════════════════ -->
    <div class="tab-panel" id="tab-setlist">
      <h2>Set List Creator</h2>
      <p class="subtitle">Upload your MP3s, arrange them into a set list, and export as one combined MP3.</p>

      <div class="upload-area" id="sl-uploadArea">
        <input type="file" id="sl-fileInput" accept=".mp3,audio/mpeg" multiple>
        <p class="upload-label">Click or drag MP3 files here (multiple)</p>
        <p class="file-name" id="sl-fileStatus"></p>
      </div>
      <div class="upload-alt">
        or <button class="gdrive-btn" id="sl-gdriveBtn" disabled>Import from Google Drive</button>
      </div>

      <div class="gdrive-notice" id="sl-gdriveNotice"></div>

      <div class="file-list" id="sl-fileList" style="display:none;">
        <p class="file-list-title">Uploaded songs:</p>
        <ul class="file-list-items" id="sl-fileListItems"></ul>
      </div>

      <div class="controls">
        <label for="sl-songCount">Songs in set list:</label>
        <input type="number" id="sl-songCount" min="1" max="100" value="3">
        <button class="action-btn" id="sl-buildSlotsBtn" style="width:auto; padding:8px 16px; margin:0; font-size:0.85rem;">Update slots</button>
      </div>

      <div class="setlist-slots" id="sl-slots"></div>

      <div class="error" id="sl-errorBox"></div>

      <button class="action-btn" id="sl-processBtn" disabled>Upload songs &amp; build set list first</button>

      <div class="progress-wrap" id="sl-progressWrap">
        <div class="progress-bar"><div class="fill" id="sl-progressFill"></div></div>
        <p class="progress-text" id="sl-progressText">Starting...</p>
      </div>

      <div class="result" id="sl-result">
        <a id="sl-downloadLink" href="#" download="setlist.mp3">Download Set List MP3</a>
        <p class="info" id="sl-resultInfo"></p>
        <div class="preview">
          <p class="preview-label">Preview:</p>
          <audio id="sl-audioPreview" controls></audio>
        </div>
      </div>
    </div>
  </div>

  <script>
    /* ═══════════════════════════════════════════════
       Google Drive configuration
       ─────────────────────────────────────────────
       To enable Google Drive import, fill in the
       three values below from your Google Cloud
       Console project. Leave them empty to disable.

       Setup steps:
       1. Go to https://console.cloud.google.com
       2. Create a project (or use an existing one)
       3. Enable "Google Picker API" and "Google Drive API"
       4. Create an API Key (Credentials > Create Credentials > API Key)
       5. Create an OAuth 2.0 Client ID (type: Web application)
          - Add your domain to "Authorized JavaScript origins"
            e.g. http://localhost:8080 for local dev
       6. Configure the OAuth consent screen
       7. Paste values below
       ═══════════════════════════════════════════════ */
    const GDRIVE_CLIENT_ID = '';  // e.g. '123456789.apps.googleusercontent.com'
    const GDRIVE_API_KEY   = '';  // e.g. 'AIzaSy...'
    const GDRIVE_APP_ID    = '';  // Your Cloud project number (numeric)

    const GDRIVE_SCOPES = 'https://www.googleapis.com/auth/drive.file';
    const AUDIO_MIMETYPES = 'audio/mpeg,audio/mp3';

    /* ═══════════════════════════════════════════════
       Shared utilities
       ═══════════════════════════════════════════════ */

    function formatSize(bytes) {
      if (bytes < 1024) return bytes + ' B';
      if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';
      return (bytes / 1048576).toFixed(1) + ' MB';
    }

    function showError(el, msg) {
      el.textContent = msg;
      el.classList.add('active');
    }

    function hideError(el) {
      el.classList.remove('active');
    }

    function setProgress(fillEl, textEl, pct, text) {
      fillEl.style.width = pct + '%';
      textEl.textContent = text;
    }

    function floatTo16(floatArr) {
      const int16 = new Int16Array(floatArr.length);
      for (let i = 0; i < floatArr.length; i++) {
        let s = floatArr[i];
        s = s < -1 ? -1 : s > 1 ? 1 : s;
        int16[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
      }
      return int16;
    }

    function encodeMP3(channels, sampleRate, numChannels, totalSamples, progressCb) {
      return new Promise((resolve) => {
        const kbps = 192;
        const encoder = new lamejs.Mp3Encoder(numChannels, sampleRate, kbps);
        const mp3Chunks = [];
        const chunkSize = 1152;

        let offset = 0;
        const isStereo = numChannels >= 2;

        function processChunk() {
          const end = Math.min(offset + chunkSize * 100, totalSamples);

          while (offset < end) {
            const remaining = totalSamples - offset;
            const len = Math.min(chunkSize, remaining);

            const leftF = channels[0].subarray(offset, offset + len);
            const left = floatTo16(leftF);

            let mp3buf;
            if (isStereo) {
              const rightF = channels[1].subarray(offset, offset + len);
              const right = floatTo16(rightF);
              mp3buf = encoder.encodeBuffer(left, right);
            } else {
              mp3buf = encoder.encodeBuffer(left);
            }

            if (mp3buf.length > 0) {
              mp3Chunks.push(mp3buf);
            }
            offset += len;
          }

          if (progressCb) {
            progressCb(offset / totalSamples);
          }

          if (offset < totalSamples) {
            setTimeout(processChunk, 0);
          } else {
            const flush = encoder.flush();
            if (flush.length > 0) {
              mp3Chunks.push(flush);
            }
            resolve(mp3Chunks);
          }
        }

        processChunk();
      });
    }

    /* ═══════════════════════════════════════════════
       Google Drive Picker integration
       ═══════════════════════════════════════════════ */

    const gdriveEnabled = !!(GDRIVE_CLIENT_ID && GDRIVE_API_KEY && GDRIVE_APP_ID);

    let gdrivePickerReady = false;
    let gdriveTokenClient = null;
    let gdriveAccessToken = null;

    function initGoogleDrive() {
      if (!gdriveEnabled) return;

      // Wait for gapi
      function waitGapi() {
        if (typeof gapi !== 'undefined') {
          gapi.load('picker', () => {
            gdrivePickerReady = true;
            enableGdriveButtons();
          });
        } else {
          setTimeout(waitGapi, 200);
        }
      }

      // Wait for GIS (Google Identity Services)
      function waitGis() {
        if (typeof google !== 'undefined' && google.accounts && google.accounts.oauth2) {
          gdriveTokenClient = google.accounts.oauth2.initTokenClient({
            client_id: GDRIVE_CLIENT_ID,
            scope: GDRIVE_SCOPES,
            callback: '', // set before each request
          });
          enableGdriveButtons();
        } else {
          setTimeout(waitGis, 200);
        }
      }

      waitGapi();
      waitGis();
    }

    function enableGdriveButtons() {
      if (!gdrivePickerReady || !gdriveTokenClient) return;
      document.querySelectorAll('.gdrive-btn').forEach(btn => btn.disabled = false);
    }

    /**
     * Open the Google Drive Picker.
     * multiSelect: if true, allow picking multiple files.
     * Returns a promise resolving to an array of { name, blob } objects.
     */
    function openDrivePicker(multiSelect) {
      return new Promise((resolve, reject) => {
        function showPicker() {
          const docsView = new google.picker.DocsView(google.picker.ViewId.DOCS);
          docsView.setIncludeFolders(true);
          docsView.setMimeTypes(AUDIO_MIMETYPES);

          const builder = new google.picker.PickerBuilder()
            .enableFeature(google.picker.Feature.NAV_HIDDEN)
            .setDeveloperKey(GDRIVE_API_KEY)
            .setAppId(GDRIVE_APP_ID)
            .setOAuthToken(gdriveAccessToken)
            .addView(docsView)
            .setTitle('Select MP3 file' + (multiSelect ? 's' : ''))
            .setCallback(async (data) => {
              if (data.action === google.picker.Action.PICKED) {
                try {
                  const docs = data[google.picker.Response.DOCUMENTS];
                  const results = [];
                  for (const doc of docs) {
                    const fileId = doc[google.picker.Document.ID];
                    const fileName = doc[google.picker.Document.NAME];
                    const blob = await downloadDriveFile(fileId);
                    results.push({ name: fileName, blob });
                  }
                  resolve(results);
                } catch (err) {
                  reject(err);
                }
              } else if (data.action === google.picker.Action.CANCEL) {
                resolve([]);
              }
            });

          if (multiSelect) {
            builder.enableFeature(google.picker.Feature.MULTISELECT_ENABLED);
          }

          builder.build().setVisible(true);
        }

        // Get or refresh the OAuth token
        gdriveTokenClient.callback = (tokenResponse) => {
          if (tokenResponse.error) {
            reject(new Error('Google auth error: ' + tokenResponse.error));
            return;
          }
          gdriveAccessToken = tokenResponse.access_token;
          showPicker();
        };

        if (gdriveAccessToken === null) {
          gdriveTokenClient.requestAccessToken({ prompt: 'consent' });
        } else {
          gdriveTokenClient.requestAccessToken({ prompt: '' });
        }
      });
    }

    async function downloadDriveFile(fileId) {
      const url = 'https://www.googleapis.com/drive/v3/files/' + encodeURIComponent(fileId) + '?alt=media';
      const response = await fetch(url, {
        headers: { 'Authorization': 'Bearer ' + gdriveAccessToken },
      });
      if (!response.ok) {
        const text = await response.text();
        throw new Error('Drive download failed (' + response.status + '): ' + text);
      }
      return response.blob();
    }

    // Show setup notice if Drive is not configured
    function showGdriveSetupNotice(noticeEl) {
      if (gdriveEnabled) return;
      noticeEl.innerHTML =
        'Google Drive import is available but needs API keys. ' +
        'Set <code>GDRIVE_CLIENT_ID</code>, <code>GDRIVE_API_KEY</code>, and ' +
        '<code>GDRIVE_APP_ID</code> at the top of the <code>&lt;script&gt;</code> in index.html. ' +
        'See the comments there for setup steps.';
      noticeEl.classList.add('active');
    }

    // Boot Google Drive
    initGoogleDrive();

    /* ═══════════════════════════════════════════════
       Tab switching
       ═══════════════════════════════════════════════ */

    document.querySelectorAll('.tab-btn').forEach((btn) => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
        btn.classList.add('active');
        document.getElementById('tab-' + btn.dataset.tab).classList.add('active');
      });
    });

    /* ═══════════════════════════════════════════════
       Tab 1: MP3 Repeater
       ═══════════════════════════════════════════════ */
    (function repeaterTab() {
      const uploadArea = document.getElementById('rpt-uploadArea');
      const fileInput  = document.getElementById('rpt-fileInput');
      const fileNameEl = document.getElementById('rpt-fileName');
      const repeatInput = document.getElementById('rpt-repeatCount');
      const processBtn = document.getElementById('rpt-processBtn');
      const progressWrap = document.getElementById('rpt-progressWrap');
      const progressFill = document.getElementById('rpt-progressFill');
      const progressTextEl = document.getElementById('rpt-progressText');
      const resultDiv  = document.getElementById('rpt-result');
      const dlLink     = document.getElementById('rpt-downloadLink');
      const resultInfo = document.getElementById('rpt-resultInfo');
      const audioPreview = document.getElementById('rpt-audioPreview');
      const errorBox   = document.getElementById('rpt-errorBox');
      const gdriveBtn  = document.getElementById('rpt-gdriveBtn');
      const gdriveNotice = document.getElementById('rpt-gdriveNotice');

      let selectedFile = null;

      function sp(pct, text) { setProgress(progressFill, progressTextEl, pct, text); }

      showGdriveSetupNotice(gdriveNotice);

      uploadArea.addEventListener('click', () => fileInput.click());
      uploadArea.addEventListener('dragover', (e) => { e.preventDefault(); uploadArea.classList.add('dragover'); });
      uploadArea.addEventListener('dragleave', () => uploadArea.classList.remove('dragover'));
      uploadArea.addEventListener('drop', (e) => {
        e.preventDefault();
        uploadArea.classList.remove('dragover');
        if (e.dataTransfer.files[0]) handleFile(e.dataTransfer.files[0]);
      });
      fileInput.addEventListener('change', () => { if (fileInput.files[0]) handleFile(fileInput.files[0]); });

      // Google Drive import for repeater (single file)
      gdriveBtn.addEventListener('click', async () => {
        try {
          gdriveBtn.disabled = true;
          gdriveBtn.textContent = 'Opening Drive...';
          const results = await openDrivePicker(false);
          if (results.length > 0) {
            const { name, blob } = results[0];
            const file = new File([blob], name, { type: 'audio/mpeg' });
            handleFile(file);
          }
        } catch (err) {
          console.error(err);
          showError(errorBox, 'Google Drive import failed: ' + err.message);
        } finally {
          gdriveBtn.disabled = false;
          gdriveBtn.textContent = 'Import from Google Drive';
        }
      });

      function handleFile(file) {
        if (!file.name.toLowerCase().endsWith('.mp3') && file.type !== 'audio/mpeg') {
          showError(errorBox, 'Please select an MP3 file.');
          return;
        }
        selectedFile = file;
        fileNameEl.textContent = file.name + ' (' + formatSize(file.size) + ')';
        uploadArea.classList.add('has-file');
        processBtn.disabled = false;
        processBtn.textContent = 'Create Repeated MP3';
        resultDiv.classList.remove('active');
        hideError(errorBox);
      }

      processBtn.addEventListener('click', async () => {
        if (!selectedFile) return;
        const repeats = parseInt(repeatInput.value, 10);
        if (isNaN(repeats) || repeats < 1 || repeats > 50) {
          showError(errorBox, 'Please enter a repeat count between 1 and 50.');
          return;
        }

        hideError(errorBox);
        processBtn.disabled = true;
        processBtn.textContent = 'Processing...';
        resultDiv.classList.remove('active');
        progressWrap.classList.add('active');
        sp(5, 'Reading file...');

        try {
          const arrayBuffer = await selectedFile.arrayBuffer();
          sp(15, 'Decoding audio...');

          const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
          audioCtx.close();

          const sampleRate = audioBuffer.sampleRate;
          const numChannels = audioBuffer.numberOfChannels;
          const originalLength = audioBuffer.length;
          const silenceSamples = Math.floor(sampleRate * 0.5);
          const totalLength = originalLength * repeats + silenceSamples * (repeats - 1);

          sp(25, 'Building repeated audio...');

          const channels = [];
          for (let ch = 0; ch < numChannels; ch++) channels.push(audioBuffer.getChannelData(ch));

          const repeatedChannels = [];
          for (let ch = 0; ch < numChannels; ch++) {
            const out = new Float32Array(totalLength);
            let offset = 0;
            for (let r = 0; r < repeats; r++) {
              out.set(channels[ch], offset);
              offset += originalLength;
              if (r < repeats - 1) offset += silenceSamples;
            }
            repeatedChannels.push(out);
          }

          sp(40, 'Encoding to MP3...');

          const mp3Data = await encodeMP3(repeatedChannels, sampleRate, numChannels, totalLength, (ratio) => {
            sp(40 + Math.floor(ratio * 55), 'Encoding to MP3... ' + Math.floor(ratio * 100) + '%');
          });

          sp(95, 'Finalizing...');

          const blob = new Blob(mp3Data, { type: 'audio/mpeg' });
          const url = URL.createObjectURL(blob);
          const baseName = selectedFile.name.replace(/\.mp3$/i, '');
          const outName = baseName + '_x' + repeats + '.mp3';

          dlLink.href = url;
          dlLink.download = outName;
          audioPreview.src = url;

          const durationSec = totalLength / sampleRate;
          resultInfo.textContent = outName + ' \u2014 ' + formatSize(blob.size) + ' \u2014 ' + Math.floor(durationSec / 60) + 'm ' + Math.floor(durationSec % 60) + 's';

          sp(100, 'Done!');
          resultDiv.classList.add('active');
        } catch (err) {
          console.error(err);
          showError(errorBox, 'Error processing audio: ' + err.message);
        } finally {
          processBtn.disabled = false;
          processBtn.textContent = 'Create Repeated MP3';
          setTimeout(() => progressWrap.classList.remove('active'), 1500);
        }
      });
    })();

    /* ═══════════════════════════════════════════════
       Tab 2: Set List Creator
       ═══════════════════════════════════════════════ */
    (function setListTab() {
      const uploadArea  = document.getElementById('sl-uploadArea');
      const fileInput   = document.getElementById('sl-fileInput');
      const fileStatus  = document.getElementById('sl-fileStatus');
      const fileListDiv = document.getElementById('sl-fileList');
      const fileListUl  = document.getElementById('sl-fileListItems');
      const songCountIn = document.getElementById('sl-songCount');
      const buildBtn    = document.getElementById('sl-buildSlotsBtn');
      const slotsDiv    = document.getElementById('sl-slots');
      const processBtn  = document.getElementById('sl-processBtn');
      const progressWrap = document.getElementById('sl-progressWrap');
      const progressFill = document.getElementById('sl-progressFill');
      const progressTextEl = document.getElementById('sl-progressText');
      const resultDiv   = document.getElementById('sl-result');
      const dlLink      = document.getElementById('sl-downloadLink');
      const resultInfo  = document.getElementById('sl-resultInfo');
      const audioPreview = document.getElementById('sl-audioPreview');
      const errorBox    = document.getElementById('sl-errorBox');
      const gdriveBtn   = document.getElementById('sl-gdriveBtn');
      const gdriveNotice = document.getElementById('sl-gdriveNotice');

      let uploadedSongs = new Map();

      function sp(pct, text) { setProgress(progressFill, progressTextEl, pct, text); }

      showGdriveSetupNotice(gdriveNotice);

      /* ── File upload handling ── */
      uploadArea.addEventListener('click', () => fileInput.click());
      uploadArea.addEventListener('dragover', (e) => { e.preventDefault(); uploadArea.classList.add('dragover'); });
      uploadArea.addEventListener('dragleave', () => uploadArea.classList.remove('dragover'));
      uploadArea.addEventListener('drop', (e) => {
        e.preventDefault();
        uploadArea.classList.remove('dragover');
        handleFiles(e.dataTransfer.files);
      });
      fileInput.addEventListener('change', () => handleFiles(fileInput.files));

      // Google Drive import for set list (multi-select)
      gdriveBtn.addEventListener('click', async () => {
        try {
          gdriveBtn.disabled = true;
          gdriveBtn.textContent = 'Opening Drive...';
          const results = await openDrivePicker(true);
          if (results.length > 0) {
            for (const { name, blob } of results) {
              const file = new File([blob], name, { type: 'audio/mpeg' });
              uploadedSongs.set(file.name, file);
            }
            hideError(errorBox);
            refreshFileList();
            refreshSlotDropdowns();
            uploadArea.classList.add('has-file');
            fileStatus.textContent = uploadedSongs.size + ' song' + (uploadedSongs.size !== 1 ? 's' : '') + ' loaded';
            updateProcessBtnState();
          }
        } catch (err) {
          console.error(err);
          showError(errorBox, 'Google Drive import failed: ' + err.message);
        } finally {
          gdriveBtn.disabled = false;
          gdriveBtn.textContent = 'Import from Google Drive';
        }
      });

      function handleFiles(files) {
        let added = 0;
        for (const file of files) {
          if (file.name.toLowerCase().endsWith('.mp3') || file.type === 'audio/mpeg') {
            uploadedSongs.set(file.name, file);
            added++;
          }
        }
        if (added === 0) {
          showError(errorBox, 'No MP3 files found in selection.');
          return;
        }
        hideError(errorBox);
        refreshFileList();
        refreshSlotDropdowns();
        uploadArea.classList.add('has-file');
        fileStatus.textContent = uploadedSongs.size + ' song' + (uploadedSongs.size !== 1 ? 's' : '') + ' loaded';
        updateProcessBtnState();
      }

      function refreshFileList() {
        fileListUl.innerHTML = '';
        if (uploadedSongs.size === 0) {
          fileListDiv.style.display = 'none';
          return;
        }
        fileListDiv.style.display = 'block';
        for (const [name, file] of uploadedSongs) {
          const li = document.createElement('li');

          const span = document.createElement('span');
          span.textContent = name + ' (' + formatSize(file.size) + ')';
          li.appendChild(span);

          const removeBtn = document.createElement('button');
          removeBtn.className = 'remove-btn';
          removeBtn.textContent = '\u00d7';
          removeBtn.title = 'Remove';
          removeBtn.addEventListener('click', () => {
            uploadedSongs.delete(name);
            refreshFileList();
            refreshSlotDropdowns();
            fileStatus.textContent = uploadedSongs.size + ' song' + (uploadedSongs.size !== 1 ? 's' : '') + ' loaded';
            if (uploadedSongs.size === 0) {
              uploadArea.classList.remove('has-file');
              fileStatus.textContent = '';
            }
            updateProcessBtnState();
          });
          li.appendChild(removeBtn);
          fileListUl.appendChild(li);
        }
      }

      /* ── Slot management ── */
      function buildSlots() {
        const count = parseInt(songCountIn.value, 10);
        if (isNaN(count) || count < 1 || count > 100) {
          showError(errorBox, 'Enter a set list size between 1 and 100.');
          return;
        }
        hideError(errorBox);

        const existing = [];
        slotsDiv.querySelectorAll('select').forEach(sel => existing.push(sel.value));

        slotsDiv.innerHTML = '';
        const names = [...uploadedSongs.keys()];

        for (let i = 0; i < count; i++) {
          const slot = document.createElement('div');
          slot.className = 'slot';

          const num = document.createElement('span');
          num.className = 'slot-number';
          num.textContent = (i + 1) + '.';
          slot.appendChild(num);

          const select = document.createElement('select');
          select.dataset.slot = i;

          const placeholder = document.createElement('option');
          placeholder.value = '';
          placeholder.textContent = '\u2014 choose a song \u2014';
          select.appendChild(placeholder);

          names.forEach((name) => {
            const opt = document.createElement('option');
            opt.value = name;
            opt.textContent = name.replace(/\.mp3$/i, '');
            select.appendChild(opt);
          });

          if (existing[i] && uploadedSongs.has(existing[i])) {
            select.value = existing[i];
          } else if (names[i]) {
            select.value = names[i];
          }

          slot.appendChild(select);
          slotsDiv.appendChild(slot);
        }
        updateProcessBtnState();
      }

      function refreshSlotDropdowns() {
        const names = [...uploadedSongs.keys()];
        slotsDiv.querySelectorAll('select').forEach((select) => {
          const current = select.value;
          while (select.options.length > 1) select.remove(1);

          names.forEach((name) => {
            const opt = document.createElement('option');
            opt.value = name;
            opt.textContent = name.replace(/\.mp3$/i, '');
            select.appendChild(opt);
          });

          if (uploadedSongs.has(current)) {
            select.value = current;
          } else {
            select.value = '';
          }
        });
        updateProcessBtnState();
      }

      buildBtn.addEventListener('click', buildSlots);
      songCountIn.addEventListener('change', buildSlots);

      buildSlots();

      function updateProcessBtnState() {
        const selects = slotsDiv.querySelectorAll('select');
        const allFilled = selects.length > 0 && [...selects].every(s => s.value !== '');
        const hasSongs = uploadedSongs.size > 0;

        if (!hasSongs) {
          processBtn.disabled = true;
          processBtn.textContent = 'Upload songs first';
        } else if (!allFilled) {
          processBtn.disabled = true;
          processBtn.textContent = 'Fill all set list slots';
        } else {
          processBtn.disabled = false;
          processBtn.textContent = 'Create Set List MP3';
        }
      }

      /* ── Processing ── */
      processBtn.addEventListener('click', async () => {
        const selects = slotsDiv.querySelectorAll('select');
        const songOrder = [...selects].map(s => s.value);

        if (songOrder.some(n => !n || !uploadedSongs.has(n))) {
          showError(errorBox, 'Please fill every slot with a song.');
          return;
        }

        hideError(errorBox);
        processBtn.disabled = true;
        processBtn.textContent = 'Processing...';
        resultDiv.classList.remove('active');
        progressWrap.classList.add('active');
        sp(2, 'Reading files...');

        try {
          const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

          const decodedCache = new Map();
          const uniqueNames = [...new Set(songOrder)];

          for (let i = 0; i < uniqueNames.length; i++) {
            const name = uniqueNames[i];
            sp(2 + Math.floor((i / uniqueNames.length) * 20), 'Decoding: ' + name.replace(/\.mp3$/i, '') + '...');
            const buf = await uploadedSongs.get(name).arrayBuffer();
            const decoded = await audioCtx.decodeAudioData(buf);
            decodedCache.set(name, decoded);
          }

          audioCtx.close();

          sp(25, 'Building set list...');

          const firstBuffer = decodedCache.get(songOrder[0]);
          const sampleRate = firstBuffer.sampleRate;
          const numChannels = Math.max(...[...decodedCache.values()].map(b => b.numberOfChannels));

          const silenceSamples = Math.floor(sampleRate * 1.0);

          let totalLength = 0;
          for (let i = 0; i < songOrder.length; i++) {
            totalLength += decodedCache.get(songOrder[i]).length;
            if (i < songOrder.length - 1) totalLength += silenceSamples;
          }

          const combined = [];
          for (let ch = 0; ch < numChannels; ch++) {
            const out = new Float32Array(totalLength);
            let offset = 0;
            for (let i = 0; i < songOrder.length; i++) {
              const buf = decodedCache.get(songOrder[i]);
              const srcCh = ch < buf.numberOfChannels ? ch : 0;
              const data = buf.getChannelData(srcCh);
              out.set(data, offset);
              offset += buf.length;
              if (i < songOrder.length - 1) offset += silenceSamples;
            }
            combined.push(out);
          }

          sp(35, 'Encoding to MP3...');

          const mp3Data = await encodeMP3(combined, sampleRate, numChannels, totalLength, (ratio) => {
            sp(35 + Math.floor(ratio * 60), 'Encoding to MP3... ' + Math.floor(ratio * 100) + '%');
          });

          sp(96, 'Finalizing...');

          const blob = new Blob(mp3Data, { type: 'audio/mpeg' });
          const url = URL.createObjectURL(blob);
          const outName = 'setlist_' + songOrder.length + '_songs.mp3';

          dlLink.href = url;
          dlLink.download = outName;
          audioPreview.src = url;

          const durationSec = totalLength / sampleRate;
          const mins = Math.floor(durationSec / 60);
          const secs = Math.floor(durationSec % 60);
          resultInfo.textContent = outName + ' \u2014 ' + formatSize(blob.size) + ' \u2014 ' + mins + 'm ' + secs + 's \u2014 ' + songOrder.length + ' songs';

          sp(100, 'Done!');
          resultDiv.classList.add('active');
        } catch (err) {
          console.error(err);
          showError(errorBox, 'Error processing audio: ' + err.message);
        } finally {
          processBtn.disabled = false;
          processBtn.textContent = 'Create Set List MP3';
          setTimeout(() => progressWrap.classList.remove('active'), 1500);
        }
      });
    })();
  </script>
</body>
</html>
